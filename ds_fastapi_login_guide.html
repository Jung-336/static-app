<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI 구글 로그인 연동 가이드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Application Structure Plan: The SPA uses a main header, a persistent left sidebar for primary navigation corresponding to the report's main sections (1-7), and a central content area. Clicking a sidebar item loads the respective section's content dynamically. Key design choices:
    - Sequential Guidance: The sidebar follows the report's logical flow, guiding users through the integration process step-by-step, which is suitable for a technical "how-to" document.
    - Focused Content Display: Only one major section is visible at a time, preventing information overload.
    - Interactive Breakdowns: Complex parts like the OAuth flow (1.2) are visualized as interactive diagrams. Multi-step procedures (e.g., Google Cloud setup in 2.1) use expandable elements. Comparative topics (e.g., Session vs. JWT in 5.1) use tabs for clarity.
    - User Flow: Users typically start from the introduction or a specific section of interest via the sidebar. They explore content, interact with diagrams/tabs/expandables, and view code snippets. The goal is to make the dense technical information digestible and easily navigable. This structure was chosen because it balances a clear overview (sidebar) with detailed, focused exploration (content area), which is effective for learning and referencing technical documentation. -->
    <!-- Visualization & Content Choices:
    - Report: 1.1 FastAPI 소개; Goal: Inform; Viz: Text, Key Feature List (HTML ul/li); Interaction: Static display; Justification: Clear presentation of core concepts.
    - Report: 1.2 Google OAuth 2.0 주요 흐름; Goal: Explain Process; Viz: HTML/CSS interactive step-diagram; Interaction: Click steps to highlight and show details; Justification: Visualizes complex flow for better understanding than text alone. Library: Vanilla JS for interaction.
    - Report: 2.1 Google Cloud Console 설정; Goal: Guide; Viz: Expandable sections (HTML/JS); Interaction: Click to toggle details for each step; Justification: Manages information density, allowing users to focus on one step at a time. Library: Vanilla JS.
    - Report: 3.1.1 프로젝트 구조화; Goal: Inform; Viz: Preformatted text for directory structure; Interaction: Static. Justification: Standard way to show code structure.
    - Report: 3.1.2 필수 Python 라이브러리; Goal: Inform; Viz: HTML table; Interaction: Static; Justification: Clear, organized list.
    - Report: 3.2.1 .env 파일 예시; Goal: Instruct; Viz: HTML pre/code block; Interaction: Static; Justification: Shows example code.
    - Report: 4.1-4.5 Authlib 구현 (각 코드 예제); Goal: Instruct; Viz: HTML pre/code blocks; Interaction: Static; Justification: Essential for a how-to guide.
    - Report: 5.1 JWT 대 서버 측 세션; Goal: Compare; Viz: Tabbed content (HTML/JS); Interaction: Click tabs to switch views; Justification: Easy comparison of two approaches. Library: Vanilla JS.
    - Report: 5.2 새로고침 토큰 암호화 (Fernet, TypeDecorator 코드); Goal: Instruct; Viz: HTML pre/code blocks; Interaction: Static.
    - Report: 6. 고급 주제; Goal: Inform; Viz: Expandable sections; Interaction: Click to toggle; Justification: Organizes multiple distinct topics. Library: Vanilla JS.
    - All sections include introductory paragraphs and relevant text summaries extracted from the report to provide context.
    - CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #FFFAF0; /* FloralWhite - A very light warm off-white */
        }
        .sidebar-item.active {
            background-color: #0EA5E9; /* sky-500 */
            color: white;
        }
        .sidebar-item:hover {
            background-color: #38BDF8; /* sky-400 */
            color: white;
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        .code-block {
            background-color: #f3f4f6; /* gray-100 */
            color: #1f2937; /* gray-800 */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.875rem;
            line-height: 1.25rem;
            white-space: pre;
        }
        .expandable-title {
            cursor: pointer;
            background-color: #E5E7EB; /* gray-200 */
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            color: #374151; /* gray-700 */
        }
        .expandable-title:hover {
            background-color: #D1D5DB; /* gray-300 */
        }
        .expandable-content {
            display: none;
            padding: 1rem;
            border: 1px solid #E5E7EB; /* gray-200 */
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            background-color: #F9FAFB; /* gray-50 */
        }
        .tab-button.active {
            background-color: #0EA5E9; /* sky-500 */
            color: white;
            border-color: #0EA5E9; /* sky-500 */
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .oauth-flow-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background-color: #F9FAFB; /* gray-50 */
            border-radius: 0.5rem;
            border: 1px solid #E5E7EB; /* gray-200 */
        }
        .oauth-flow-actor {
            background-color: #BFDBFE; /* blue-200 */
            color: #1E3A8A; /* blue-800 */
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            font-weight: 500;
            text-align: center;
            min-width: 150px;
        }
        .oauth-flow-step {
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 0.5rem;
            border: 1px dashed #9CA3AF; /* gray-400 */
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .oauth-flow-step:hover, .oauth-flow-step.active {
            background-color: #E0F2FE; /* sky-100 */
            border-color: #0EA5E9; /* sky-500 */
        }
        .oauth-flow-arrow {
            font-size: 1.5rem;
            margin: 0 0.5rem;
            color: #6B7280; /* gray-500 */
        }
        .oauth-flow-step-number {
            background-color: #0EA5E9; /* sky-500 */
            color: white;
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 0.75rem;
            flex-shrink: 0;
        }
        .oauth-flow-step-text {
            flex-grow: 1;
            color: #374151; /* gray-700 */
        }
        .oauth-flow-details {
            margin-top: 0.5rem;
            padding: 0.75rem;
            background-color: white;
            border: 1px solid #E5E7EB; /* gray-200 */
            border-radius: 0.375rem;
            display: none; /* Initially hidden */
            color: #4B5563; /* gray-600 */
        }

        h2 {
            font-size: 1.75rem; /* text-2xl equiv */
            font-weight: 700; /* bold */
            color: #C2410C; /* amber-700 */
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #FDBA74; /* amber-300 */
        }
        h3 {
            font-size: 1.25rem; /* text-xl equiv */
            font-weight: 600; /* semibold */
            color: #7C2D12; /* amber-800 */
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        p, ul, ol, table {
            margin-bottom: 1rem;
            line-height: 1.6;
            color: #374151; /* gray-700 */
        }
        ul, ol {
            padding-left: 1.5rem;
        }
        li {
            margin-bottom: 0.25rem;
        }
        a {
            color: #0284C7; /* sky-600 */
            text-decoration: underline;
        }
        a:hover {
            color: #0369A1; /* sky-700 */
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #D1D5DB; /* gray-300 */
            padding: 0.5rem 0.75rem;
            text-align: left;
        }
        th {
            background-color: #F3F4F6; /* gray-100 */
            font-weight: 600;
        }
        .main-content-area {
            min-height: calc(100vh - 4rem); /* Adjust based on header height */
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
            height: 350px;
            max-height: 400px;
            background-color: #F9FAFB; /* gray-50 */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        /* For smaller screens, adjust chart container height */
        @media (max-width: 768px) {
            .chart-container {
                height: 300px;
                max-height: 350px;
            }
             h2 { font-size: 1.5rem; }
             h3 { font-size: 1.125rem; }
        }
        /* Specific styles for the OAuth flow actors */
        .actor-client { background-color: #A5B4FC; color: #312E81; } /* Indigo-300, Indigo-900 */
        .actor-auth-server { background-color: #FDBA74; color: #7C2D12; } /* Amber-300, Amber-800 */
        .actor-resource-server { background-color: #86EFAC; color: #14532D; } /* Green-300, Green-800 */

        .sticky-sidebar {
            position: -webkit-sticky; /* Safari */
            position: sticky;
            top: 4rem; /* Adjust if header height changes */
            height: calc(100vh - 4rem); /* Full viewport height minus header */
            overflow-y: auto;
        }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="text-stone-800">
    <header class="bg-amber-600 text-white p-4 shadow-md sticky top-0 z-50">
        <h1 class="text-3xl font-bold text-center">FastAPI와 Google 로그인 API 연동 가이드</h1>
    </header>

    <div class="flex flex-col md:flex-row">
        <aside class="w-full md:w-1/4 bg-stone-100 p-4 sticky-sidebar">
            <nav>
                <h2 class="text-xl font-semibold mb-3 text-amber-700">목차</h2>
                <ul>
                    <li><a href="#" class="sidebar-item block p-2 mb-1 rounded-md transition-colors duration-200" data-section="intro">1. 서론</a></li>
                    <li><a href="#" class="sidebar-item block p-2 mb-1 rounded-md transition-colors duration-200" data-section="google-cloud-setup">2. Google Cloud 프로젝트 설정</a></li>
                    <li><a href="#" class="sidebar-item block p-2 mb-1 rounded-md transition-colors duration-200" data-section="fastapi-setup">3. FastAPI 애플리케이션 설정</a></li>
                    <li><a href="#" class="sidebar-item block p-2 mb-1 rounded-md transition-colors duration-200" data-section="oauth-flow-impl">4. Authlib OAuth 2.0 흐름 구현</a></li>
                    <li><a href="#" class="sidebar-item block p-2 mb-1 rounded-md transition-colors duration-200" data-section="session-mgmt">5. 인증 후 세션 관리 및 API 보호</a></li>
                    <li><a href="#" class="sidebar-item block p-2 mb-1 rounded-md transition-colors duration-200" data-section="advanced-topics">6. 고급 주제 및 모범 사례</a></li>
                    <li><a href="#" class="sidebar-item block p-2 mb-1 rounded-md transition-colors duration-200" data-section="conclusion">7. 결론 및 향후 방향</a></li>
                </ul>
            </nav>
        </aside>

        <main class="w-full md:w-3/4 p-6 md:p-8 main-content-area bg-white shadow-lg">
            <section id="intro" class="content-section">
                <h2>1. 서론</h2>
                <p>이 섹션에서는 FastAPI 프레임워크와 Google OAuth 2.0 및 OpenID Connect(OIDC)에 대한 기본적인 이해를 돕습니다. 최신 웹 애플리케이션 개발에서 사용자 인증의 중요성과 Google 로그인을 통합함으로써 얻을 수 있는 이점을 소개합니다.</p>
                
                <h3>1.1. FastAPI 프레임워크 소개</h3>
                <p>FastAPI는 Python 3.6+를 기반으로 API를 구축하기 위한 현대적이고 빠른 웹 프레임워크입니다. ASGI(Asynchronous Server Gateway Interface)를 기반으로 높은 성능을 제공하며, Python 타입 힌트를 활용하여 데이터 유효성 검사, 직렬화, 자동 API 문서 생성을 지원합니다.</p>
                <h4>FastAPI의 핵심 기능:</h4>
                <ul>
                    <li><strong>고성능 (High Performance):</strong> Starlette과 Pydantic 기반으로 매우 높은 성능을 제공합니다.</li>
                    <li><strong>개발 용이성 (Easy to Use):</strong> 직관적이고 간결한 구문으로 빠른 개발이 가능합니다.</li>
                    <li><strong>자동 API 문서화 (Automatic API Documentation):</strong> OpenAPI 및 JSON Schema 형식의 문서를 자동 생성합니다.</li>
                    <li><strong>데이터 유효성 검사 및 직렬화 (Data Validation and Serialization):</strong> Pydantic을 사용하여 강력한 데이터 검증 및 직렬화를 수행합니다.</li>
                    <li><strong>의존성 주입 시스템 (Dependency Injection System):</strong> 코드 재사용성과 테스트 용이성을 향상시킵니다.</li>
                    <li><strong>보안 기능:</strong> 다양한 인증 및 권한 부여 메커니즘을 지원합니다.</li>
                </ul>
                <h4>FastAPI의 보안 기능 개요:</h4>
                <p><code>fastapi.security</code> 모듈을 통해 API 키, HTTP 기본 인증, OAuth2, OpenID Connect 등 다양한 보안 스킴을 쉽게 통합할 수 있습니다. 이는 OpenAPI 사양과 통합되어 자동 문서에도 반영됩니다.</p>

                <h3>1.2. Google OAuth 2.0 및 OpenID Connect (OIDC) 이해</h3>
                <p>Google API는 인증 및 권한 부여를 위해 OAuth 2.0 프로토콜을 사용합니다. OAuth 2.0은 사용자가 자격 증명을 직접 노출하지 않고 제3자 애플리케이션에 리소스 접근 권한을 부여하는 표준 프레임워크입니다. OpenID Connect(OIDC)는 OAuth 2.0 위에 구축된 ID 계층으로, 최종 사용자 인증 결과를 확인하고 프로필 정보를 얻는 데 사용됩니다.</p>
                <h4>OAuth 2.0 기본 개념:</h4>
                <ul>
                    <li><strong>리소스 소유자 (Resource Owner):</strong> 최종 사용자.</li>
                    <li><strong>클라이언트 (Client):</strong> FastAPI 애플리케이션.</li>
                    <li><strong>인증 서버 (Authorization Server):</strong> Google 인증 서버.</li>
                    <li><strong>리소스 서버 (Resource Server):</strong> Google API 서버.</li>
                </ul>
                <h4>주요 용어:</h4>
                <ul>
                    <li><strong>접근 토큰 (Access Token):</strong> 리소스 접근용 단기 자격 증명.</li>
                    <li><strong>새로고침 토큰 (Refresh Token):</strong> 새 접근 토큰 발급용 장기 자격 증명.</li>
                    <li><strong>범위 (Scope):</strong> 허용된 리소스 및 작업 범위.</li>
                    <li><strong>ID 토큰 (ID Token):</strong> OIDC에서 사용하는 JWT 형식의 토큰으로, 사용자 인증 정보 포함.</li>
                </ul>

                <h4>Google OAuth 2.0 주요 흐름 (Authorization Code Grant Flow):</h4>
                <p>웹 서버 애플리케이션에 적합한 이 흐름은 다음과 같은 단계로 진행됩니다. 아래 다이어그램의 각 단계를 클릭하여 설명을 확인하세요.</p>
                <div class="oauth-flow-diagram my-4">
                    <div class="flex justify-around w-full mb-4">
                        <div class="oauth-flow-actor actor-client">클라이언트 (FastAPI 앱)</div>
                        <div class="oauth-flow-actor actor-auth-server">Google 인증 서버</div>
                        <div class="oauth-flow-actor actor-resource-server">Google 리소스 서버</div>
                    </div>
                    
                    <div class="oauth-flow-step" data-step="1">
                        <div class="oauth-flow-step-number">1</div>
                        <div class="oauth-flow-step-text">사용자 Google 인증 서버로 리디렉션</div>
                    </div>
                    <div class="oauth-flow-details" id="flow-detail-1">클라이언트가 사용자를 Google 인증 서버로 보냅니다. 요청에는 클라이언트 ID, 리디렉션 URI, 범위(scope)가 포함됩니다.</div>

                    <div class="oauth-flow-step" data-step="2">
                        <div class="oauth-flow-step-number">2</div>
                        <div class="oauth-flow-step-text">Google 사용자 인증 및 동의 요청</div>
                    </div>
                     <div class="oauth-flow-details" id="flow-detail-2">Google이 사용자를 인증하고, 앱이 요청한 권한에 대한 사용자 동의를 구합니다.</div>

                    <div class="oauth-flow-step" data-step="3">
                        <div class="oauth-flow-step-number">3</div>
                        <div class="oauth-flow-step-text">승인 코드 발급 및 사용자 리디렉션</div>
                    </div>
                    <div class="oauth-flow-details" id="flow-detail-3">사용자가 동의하면, Google은 승인 코드를 발급하여 지정된 리디렉션 URI(클라이언트의 콜백 엔드포인트)로 사용자를 다시 보냅니다.</div>

                    <div class="oauth-flow-step" data-step="4">
                        <div class="oauth-flow-step-number">4</div>
                        <div class="oauth-flow-step-text">승인 코드로 토큰 요청</div>
                    </div>
                    <div class="oauth-flow-details" id="flow-detail-4">클라이언트는 받은 승인 코드를 사용하여 Google 토큰 엔드포인트에 접근 토큰과 새로고침 토큰을 요청합니다. 이 요청에는 클라이언트 ID, 클라이언트 보안 비밀 등이 포함됩니다.</div>
                    
                    <div class="oauth-flow-step" data-step="5">
                        <div class="oauth-flow-step-number">5</div>
                        <div class="oauth-flow-step-text">접근/새로고침/ID 토큰 반환</div>
                    </div>
                    <div class="oauth-flow-details" id="flow-detail-5">Google 토큰 엔드포인트는 유효한 요청에 대해 접근 토큰, ID 토큰, (요청 시) 새로고침 토큰을 반환합니다.</div>

                    <div class="oauth-flow-step" data-step="6">
                        <div class="oauth-flow-step-number">6</div>
                        <div class="oauth-flow-step-text">접근 토큰으로 Google API 호출</div>
                    </div>
                    <div class="oauth-flow-details" id="flow-detail-6">클라이언트는 접근 토큰을 사용하여 Google API에 요청을 보내 사용자 데이터에 접근합니다. 접근 토큰 만료 시 새로고침 토큰으로 새 접근 토큰을 얻습니다.</div>
                </div>
            </section>

            <section id="google-cloud-setup" class="content-section">
                <h2>2. Google Cloud 프로젝트 설정</h2>
                <p>FastAPI 애플리케이션에서 Google 로그인을 사용하기 위해서는 먼저 Google Cloud Console에서 OAuth 2.0 클라이언트를 설정해야 합니다. 이 과정은 프로젝트 생성, API 활성화, OAuth 동의 화면 구성, 그리고 클라이언트 ID 및 보안 비밀 생성을 포함합니다.</p>

                <h3>2.1. Google Cloud Console 설정 단계</h3>
                <p>다음은 Google Cloud Console에서 수행해야 할 주요 단계들입니다. 각 단계를 클릭하여 상세 내용을 확인하세요.</p>

                <div class="expandable-container">
                    <div class="expandable-title"><span>2.1.1. 새 프로젝트 생성 또는 기존 프로젝트 선택</span><span class="arrow">▼</span></div>
                    <div class="expandable-content">
                        <p>Google Cloud Console에 로그인 후, 새 프로젝트를 만들거나 이미 있는 프로젝트를 선택합니다. 프로젝트는 Google Cloud 리소스를 관리하는 기본 단위입니다.</p>
                    </div>
                </div>
                <div class="expandable-container">
                    <div class="expandable-title"><span>2.1.2. 필수 API 활성화</span><span class="arrow">▼</span></div>
                    <div class="expandable-content">
                        <p>Google 로그인을 위해 "Google People API" 또는 관련 ID 서비스를 프로젝트에서 활성화해야 합니다. API 라이브러리에서 해당 API를 검색하여 "사용 설정"합니다. API를 활성화해야 애플리케이션이 Google 인증 서버와 통신할 수 있습니다.</p>
                    </div>
                </div>
                <div class="expandable-container">
                    <div class="expandable-title"><span>2.1.3. OAuth 동의 화면 구성</span><span class="arrow">▼</span></div>
                    <div class="expandable-content">
                        <p>사용자가 애플리케이션에 데이터 접근 권한을 부여할 때 표시되는 화면입니다.</p>
                        <ul>
                            <li><strong>사용자 유형:</strong> "외부"를 선택하면 Google 계정을 가진 모든 사용자가 앱을 사용할 수 있습니다 (테스트 단계).</li>
                            <li><strong>애플리케이션 정보:</strong> 앱 이름, 사용자 지원 이메일, 로고(선택)를 입력합니다.</li>
                            <li><strong>승인된 도메인:</strong> 앱의 홈페이지, 개인정보처리방침 URL이 호스팅되는 도메인을 추가합니다.</li>
                            <li><strong>범위 (Scopes):</strong> 앱이 요청할 권한을 선택합니다. 기본적으로 `openid`, `email`, `profile`이 필요합니다.</li>
                            <li><strong>테스트 사용자 추가:</strong> 앱이 게시(검증)되지 않은 경우, 테스트할 Google 계정을 등록합니다.</li>
                        </ul>
                    </div>
                </div>
                <div class="expandable-container">
                    <div class="expandable-title"><span>2.1.4. OAuth 2.0 클라이언트 ID 및 보안 비밀 생성</span><span class="arrow">▼</span></div>
                    <div class="expandable-content">
                        <p>애플리케이션이 Google의 OAuth 2.0 서버와 통신하기 위한 자격 증명입니다.</p>
                        <ul>
                            <li><strong>애플리케이션 유형:</strong> "웹 애플리케이션"을 선택합니다.</li>
                            <li><strong>이름:</strong> 클라이언트를 식별할 이름을 지정합니다.</li>
                            <li><strong>승인된 JavaScript 원본:</strong> (선택 사항) 프론트엔드가 Google API를 직접 호출하는 경우 프론트엔드 URL(예: `http://localhost:3000`)을 추가합니다.</li>
                            <li><strong>승인된 리디렉션 URI:</strong> Google 인증 후 사용자를 다시 보낼 FastAPI 애플리케이션의 콜백 엔드포인트 URI입니다 (예: `http://localhost:8000/auth/google/callback`). 이 URI는 정확히 일치해야 하며, 프로덕션에서는 HTTPS를 사용해야 합니다.</li>
                        </ul>
                        <p>생성된 클라이언트 ID와 클라이언트 보안 비밀은 안전하게 보관해야 합니다. Google Cloud Console에서 JSON 파일을 다운로드하여 이 정보를 관리할 수 있습니다.</p>
                    </div>
                </div>
            </section>
            
            <section id="fastapi-setup" class="content-section">
                <h2>3. FastAPI 애플리케이션 설정 및 라이브러리 통합</h2>
                <p>Google Cloud 설정 후, FastAPI 애플리케이션을 구성하고 필요한 Python 라이브러리를 통합합니다. 프로젝트 구조화, 라이브러리 설치, 민감 정보 관리가 중요합니다.</p>

                <h3>3.1. FastAPI 프로젝트 설정</h3>
                <div class="tabs-container my-4">
                    <div class="flex border-b border-gray-300">
                        <button class="tab-button py-2 px-4 text-gray-600 hover:text-sky-600 focus:outline-none active" data-tab="project-structure">3.1.1. 프로젝트 구조화</button>
                        <button class="tab-button py-2 px-4 text-gray-600 hover:text-sky-600 focus:outline-none" data-tab="libraries">3.1.2. 필수 Python 라이브러리</button>
                    </div>

                    <div id="project-structure" class="tab-content p-4 active">
                        <p>잘 구성된 프로젝트 구조는 유지보수성과 확장성을 높입니다. 일반적인 FastAPI 프로젝트 구조 예시입니다:</p>
                        <div class="code-block">
fastapi-google-auth-project/
├── app/
│   ├── __init__.py
│   ├── main.py             # FastAPI 앱 인스턴스 및 주요 설정
│   ├── core/
│   │   ├── __init__.py
│   │   └── config.py       # 환경 변수 및 설정 관리
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── auth.py         # 인증 관련 라우트
│   │   └── users.py        # 사용자 관련 라우트
│   ├── schemas/            # Pydantic 스키마
│   ├── services/           # 비즈니스 로직
│   ├── models/             # SQLAlchemy 모델 (DB 사용 시)
│   └── dependencies/       # 의존성 함수
├── tests/                  # 테스트 코드
├── .env                    # 환경 변수 파일
├── .gitignore
└── requirements.txt        # Python 라이브러리 의존성
                        </div>
                    </div>
                    <div id="libraries" class="tab-content p-4">
                        <p>Google 로그인 연동을 위한 주요 Python 라이브러리입니다:</p>
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">라이브러리</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">역할</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">설치 명령어</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr><td><code>fastapi</code></td><td>핵심 FastAPI 프레임워크</td><td><code>pip install fastapi</code></td></tr>
                                <tr><td><code>uvicorn[standard]</code></td><td>ASGI 서버</td><td><code>pip install "uvicorn[standard]"</code></td></tr>
                                <tr><td><code>authlib</code></td><td>OAuth 2.0 클라이언트</td><td><code>pip install "authlib[httpx]>=1.0.0"</code></td></tr>
                                <tr><td><code>python-jose[cryptography]</code></td><td>JWT 처리</td><td><code>pip install "python-jose[cryptography]>=3.3.0"</code></td></tr>
                                <tr><td><code>google-auth</code></td><td>Google ID 토큰 검증</td><td><code>pip install "google-auth>=2.0.0"</code></td></tr>
                                <tr><td><code>cryptography</code></td><td>데이터 암호화 (Fernet)</td><td><code>pip install "cryptography>=3.4"</code></td></tr>
                                <tr><td><code>sqlalchemy</code></td><td>ORM (DB 사용 시)</td><td><code>pip install "sqlalchemy>=2.0"</code></td></tr>
                                <tr><td><code>python-dotenv</code></td><td>.env 파일 로드</td><td><code>pip install "python-dotenv>=0.19"</code></td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <h3>3.2. 민감한 자격 증명 및 구성 관리</h3>
                <p>클라이언트 ID, 보안 비밀 등 민감 정보는 코드에 하드코딩하지 않고 환경 변수로 관리합니다. <code>python-dotenv</code>와 Pydantic <code>BaseSettings</code>를 사용합니다.</p>
                <h4>1. <code>.env</code> 파일 생성 (프로젝트 루트)</h4>
                <div class="code-block">
GOOGLE_CLIENT_ID="your-google-client-id"
GOOGLE_CLIENT_SECRET="your-google-client-secret"
GOOGLE_REDIRECT_URI="http://localhost:8000/auth/google/callback"
APP_SECRET_KEY="a-very-strong-random-secret-key-for-sessions"
FERNET_ENCRYPTION_KEY="your-fernet-encryption-key-base64-encoded"
DATABASE_URL="postgresql+asyncpg://user:password@host:port/dbname"
FRONTEND_URL="http://localhost:3000"
                </div>
                <p class="mt-2"><strong>주의:</strong> <code>.env</code> 파일은 <code>.gitignore</code>에 추가하여 버전 관리에 포함되지 않도록 합니다.</p>

                <h4>2. Pydantic <code>BaseSettings</code>를 사용한 설정 클래스 정의 (<code>app/core/config.py</code>)</h4>
                <div class="code-block">
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional

class Settings(BaseSettings):
    GOOGLE_CLIENT_ID: str
    GOOGLE_CLIENT_SECRET: str
    GOOGLE_REDIRECT_URI: str
    APP_SECRET_KEY: str
    FERNET_ENCRYPTION_KEY: bytes # Fernet 키는 bytes 타입
    DATABASE_URL: str = "sqlite+aiosqlite:///./test.db"
    FRONTEND_URL: str = "http://localhost:3000"

    model_config = SettingsConfigDict(env_file=".env", extra='ignore')

settings = Settings()
                </div>
                <p class="mt-2"><code>BaseSettings</code>는 <code>.env</code> 파일에서 환경 변수를 읽어오고 타입 검증을 수행합니다. <code>settings</code> 객체를 통해 애플리케이션 전체에서 구성 값에 접근합니다.</p>
            </section>

            <section id="oauth-flow-impl" class="content-section">
                <h2>4. Authlib을 사용한 Google OAuth 2.0 흐름 구현</h2>
                <p><code>Authlib</code> 라이브러리를 사용하여 FastAPI에서 Google OAuth 2.0 인증 흐름을 구현합니다. <code>Authlib</code>은 Starlette과의 통합을 지원하여 FastAPI와 잘 연동됩니다. 이 섹션에서는 클라이언트 등록, 로그인 시작 및 콜백 엔드포인트 생성, ID 토큰 검증 및 사용자 정보 추출, 그리고 세션 관리를 위한 <code>SessionMiddleware</code> 설정을 다룹니다.</p>

                <h3>4.1. Authlib에서 Google OAuth 클라이언트 등록</h3>
                <p>FastAPI 애플리케이션 내에서 <code>Authlib</code>의 <code>OAuth</code> 객체를 초기화하고 Google OAuth 2.0 공급자를 등록합니다. (예: <code>app/services/auth_service.py</code>)</p>
                <div class="code-block">
from authlib.integrations.starlette_client import OAuth
from app.core.config import settings

oauth_service = OAuth()

oauth_service.register(
    name='google',
    client_id=settings.GOOGLE_CLIENT_ID,
    client_secret=settings.GOOGLE_CLIENT_SECRET,
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_kwargs={
        'scope': 'openid email profile',
        'prompt': 'consent', // 매번 동의 요청 (개발 시 유용)
    }
)
                </div>
                <p class="mt-2"><code>server_metadata_url</code>을 사용하면 Authlib이 Google의 인증, 토큰, 사용자 정보 엔드포인트 등의 메타데이터를 자동으로 가져옵니다.</p>

                <h3>4.2. 로그인 시작 엔드포인트 생성 (예: <code>/login/google</code>)</h3>
                <p>사용자가 Google 로그인을 시작할 수 있도록 FastAPI 엔드포인트를 생성합니다. 이 엔드포인트는 사용자를 Google 인증 페이지로 리디렉션합니다. (예: <code>app/routers/auth.py</code>)</p>
                <div class="code-block">
from fastapi import APIRouter, Request
from starlette.responses import RedirectResponse
from app.services.auth_service import oauth_service # 위에서 정의

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.get('/login/google')
async def login_via_google(request: Request):
    redirect_uri = request.url_for('auth_google_callback') # 콜백 라우트 이름
    return await oauth_service.google.authorize_redirect(request, str(redirect_uri))
                </div>
                <p class="mt-2"><code>authorize_redirect</code> 메소드는 CSRF 방지를 위해 <code>state</code> 매개변수를 생성하고 세션에 저장한 후, Google 인증 페이지로 리디렉션합니다.</p>
                
                <h3>4.3. 콜백 엔드포인트 생성 (예: <code>/auth/google/callback</code>)</h3>
                <p>Google 인증 후 사용자가 리디렉션될 콜백 엔드포인트입니다. 여기서 승인 코드를 토큰으로 교환하고 사용자 정보를 처리합니다. (예: <code>app/routers/auth.py</code>)</p>
                <div class="code-block">
from app.core.config import settings # FRONTEND_URL 사용

@router.get('/google/callback', name='auth_google_callback')
async def auth_google_callback(request: Request):
    try:
        token = await oauth_service.google.authorize_access_token(request)
    except Exception as e:
        return RedirectResponse(url=f"{settings.FRONTEND_URL}/login?error=google_auth_failed")

    user_info = token.get('userinfo')
    if not user_info:
        return RedirectResponse(url=f"{settings.FRONTEND_URL}/login?error=user_info_missing")

    # 사용자 정보를 세션에 저장 (SessionMiddleware 필요)
    request.session['user'] = dict(user_info)
    request.session['access_token'] = token.get('access_token')
    # ... (DB 저장 로직 등) ...

    return RedirectResponse(url=settings.FRONTEND_URL) # 프론트엔드 대시보드 등
                </div>
                <p class="mt-2"><code>authorize_access_token</code>은 <code>state</code> 검증 후 승인 코드를 사용하여 토큰을 요청하고, 성공 시 토큰 정보를 반환합니다. <code>token['userinfo']</code>에 파싱된 ID 토큰 클레임이 포함됩니다.</p>

                <h3>4.4. Google ID 토큰 검증 및 사용자 정보 추출</h3>
                <p><code>Authlib</code>은 <code>server_metadata_url</code>과 <code>jwks_uri</code>를 통해 ID 토큰 서명 및 클레임을 자동으로 검증하고, <code>token['userinfo']</code>에 사용자 정보를 저장합니다. 개발자는 이 정보를 직접 사용하면 됩니다.</p>
                <div class="code-block">
# 콜백 엔드포인트 내 예시:
user_info_from_authlib = token.get('userinfo')

if user_info_from_authlib:
    google_user_id = user_info_from_authlib.get('sub')
    email = user_info_from_authlib.get('email')
    name = user_info_from_authlib.get('name')
    # ... 기타 프로필 정보 ...
    print(f"사용자 정보: {user_info_from_authlib}")
                </div>
                <p class="mt-2">표준 OpenID Connect 클레임(<code>sub</code>, <code>email</code>, <code>name</code>, <code>picture</code> 등)을 통해 사용자 프로필 정보를 얻을 수 있습니다.</p>

                <h3>4.5. 세션 관리를 위한 Starlette <code>SessionMiddleware</code> 설정</h3>
                <p>OAuth 2.0의 <code>state</code> 매개변수 관리 및 인증 후 사용자 정보 유지를 위해 서버 측 세션이 필요합니다. FastAPI는 Starlette의 <code>SessionMiddleware</code>를 사용합니다. (<code>app/main.py</code>)</p>
                <div class="code-block">
from fastapi import FastAPI
from starlette.middleware.sessions import SessionMiddleware
from app.core.config import settings
# ... other imports ...

app = FastAPI(title="FastAPI Google Auth Demo")

app.add_middleware(
    SessionMiddleware,
    secret_key=settings.APP_SECRET_KEY,
    session_cookie="fastapi_google_session", # 세션 쿠키 이름
    max_age=14 * 24 * 60 * 60,  # 14일 (초 단위)
    same_site="lax",
    https_only=False # 프로덕션에서는 True 권장
)
# ... 라우터 추가 등 ...
                </div>
                <p class="mt-2"><code>secret_key</code>는 쿠키 서명에 사용되며 안전하게 관리해야 합니다. 설정 후 <code>request.session</code> 딕셔너리를 통해 세션 데이터에 접근할 수 있습니다.</p>
            </section>
            
            <section id="session-mgmt" class="content-section">
                <h2>5. 인증 후 세션 관리 및 API 보호</h2>
                <p>Google OAuth 2.0 인증 후, FastAPI 백엔드는 사용자 인증 상태를 유지하고 보호된 API 엔드포인트 접근을 제어해야 합니다. 서버 측 세션과 JWT 방식을 비교하고, 새로고침 토큰 관리 및 로그아웃 구현을 다룹니다.</p>

                <h3>5.1. 인증된 사용자 상태 관리: JWT 대 서버 측 세션</h3>
                <p>사용자 인증 상태 관리에는 서버 측 세션(권장)과 애플리케이션별 JWT 발행 방식이 있습니다.</p>
                <div class="tabs-container my-4">
                    <div class="flex border-b border-gray-300">
                        <button class="tab-button py-2 px-4 text-gray-600 hover:text-sky-600 focus:outline-none active" data-tab="server-session">옵션 1: 서버 측 세션 (권장)</button>
                        <button class="tab-button py-2 px-4 text-gray-600 hover:text-sky-600 focus:outline-none" data-tab="app-jwt">옵션 2: 애플리케이션별 JWT</button>
                    </div>

                    <div id="server-session" class="tab-content p-4 active">
                        <p>사용자 정보를 서버 측 세션에 저장하고, 클라이언트에게 세션 ID가 포함된 쿠키를 발급합니다. FastAPI의 <code>SessionMiddleware</code>를 사용합니다.</p>
                        <h4>세션 기반 인증을 위한 FastAPI 의존성 함수 (<code>app/dependencies/auth_deps.py</code>)</h4>
                        <div class="code-block">
from fastapi import Request, HTTPException, status, Depends
from typing import Dict

async def get_current_session_user(request: Request) -> Dict:
    user = request.session.get('user')
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    return user
                        </div>
                        <h4>보호된 경로에 의존성 적용 (<code>app/routers/users.py</code>)</h4>
                        <div class="code-block">
from fastapi import APIRouter, Depends
from app.dependencies.auth_deps import get_current_session_user

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/me")
async def read_users_me(current_user: Dict = Depends(get_current_session_user)):
    return current_user
                        </div>
                        <p class="mt-2"><strong>장점:</strong> 보안성 (민감 정보 서버 저장), 세션 무효화 용이. <strong>단점:</strong> 확장 시 세션 저장소 부하, 약간의 성능 오버헤드.</p>
                    </div>

                    <div id="app-jwt" class="tab-content p-4">
                        <p>Google 인증 후 FastAPI 앱 자체에서 JWT를 생성하여 클라이언트에 전달합니다. 클라이언트는 요청 시 JWT를 헤더에 담아 전송합니다.</p>
                        <h4>JWT 생성 (<code>python-jose</code> 사용, <code>app/services/auth_service.py</code>)</h4>
                        <div class="code-block">
from datetime import datetime, timedelta, timezone
from jose import jwt
# from app.core.config import settings # JWT_SECRET_KEY, JWT_ALGORITHM 등 필요

def create_application_jwt(data: dict, expires_delta: timedelta = timedelta(minutes=30)) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + expires_delta
    to_encode.update({"exp": expire})
    # encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)
    encoded_jwt = jwt.encode(to_encode, "YOUR_JWT_SECRET_KEY", algorithm="HS256") # 실제 키와 알고리즘 사용
    return encoded_jwt
                        </div>
                        <p class="mt-2">생성된 JWT는 HTTPOnly 쿠키에 저장하거나 프론트엔드 메모리에 관리합니다.</p>
                        <h4>JWT 기반 인증 의존성 함수 (<code>app/dependencies/auth_deps.py</code>)</h4>
                        <p><code>OAuth2PasswordBearer</code>와 <code>jose.jwt.decode</code>를 사용하여 JWT를 검증합니다. (구현 생략)</p>
                        <p class="mt-2"><strong>장점:</strong> 상태 비저장 (서버 부하 적고 확장 용이). <strong>단점:</strong> 토큰 탈취 위험, 토큰 무효화 어려움.</p>
                        <p class="mt-2"><strong>일반 웹 앱은 서버 측 세션이, 상태 비저장 API나 모바일 클라이언트는 JWT가 적합할 수 있습니다.</strong></p>
                    </div>
                </div>

                <h3>5.2. Google OAuth 새로고침 토큰의 안전한 저장 및 관리</h3>
                <p>새로고침 토큰은 접근 토큰 만료 시 새 접근 토큰을 발급받는 데 사용되며, 매우 민감하므로 안전하게 저장/관리해야 합니다.</p>
                <ul>
                    <li><strong>저장 전략:</strong> 사용자 계정과 연결하여 서버 측 DB에 저장.</li>
                    <li><strong>암호화:</strong> DB 저장 시 강력한 암호화 사용 (예: <code>cryptography</code> 라이브러리의 Fernet).</li>
                </ul>
                <h4>Fernet을 사용한 암호화/복호화 예시 (<code>cryptography</code>)</h4>
                <div class="code-block">
from cryptography.fernet import Fernet

# Fernet 키 생성 (한 번 실행 후.env 등에 안전하게 저장)
# fernet_key = Fernet.generate_key()
# print(fernet_key.decode())

# 설정에서 키 로드 (bytes 타입이어야 함)
# fernet_instance = Fernet(settings.FERNET_ENCRYPTION_KEY)

# 암호화:
# refresh_token_plain = "google_refresh_token_string"
# encrypted_token_bytes = fernet_instance.encrypt(refresh_token_plain.encode('utf-8'))
# DB에 encrypted_token_bytes 저장

# 복호화:
# decrypted_token_bytes = fernet_instance.decrypt(encrypted_token_bytes_from_db)
# refresh_token_plain = decrypted_token_bytes.decode('utf-8')
                </div>
                <p class="mt-2">SQLAlchemy <code>TypeDecorator</code>를 사용하면 암호화/복호화를 투명하게 처리할 수 있습니다. 키 회전, 토큰 유효 기간 및 폐기, DB 보안도 중요합니다.</p>
                
                <h3>5.3. 로그아웃 엔드포인트 구현</h3>
                <p>사용자 로그아웃 기능을 제공합니다. 서버 측 세션 사용 시 세션에서 사용자 정보를 제거합니다. (<code>app/routers/auth.py</code>)</p>
                <div class="code-block">
@router.post('/logout')
async def logout(request: Request):
    if 'user' in request.session:
        del request.session['user']
    # ... 다른 세션 정보 제거 ...
    # (선택 사항) Google 측 토큰 폐기
    return {"message": "Successfully logged out"}
                </div>
                <p class="mt-2">JWT 사용 시 클라이언트에서 JWT를 삭제하고, 필요시 서버 측 블랙리스트를 사용하거나 HTTPOnly 쿠키를 삭제합니다.</p>
            </section>

            <section id="advanced-topics" class="content-section">
                <h2>6. 고급 주제 및 모범 사례</h2>
                <p>FastAPI와 Google 로그인 연동 후 애플리케이션의 안정성, 보안성, 유지보수성을 높이기 위한 방안들입니다. 각 항목을 클릭하여 상세 내용을 확인하세요.</p>

                <div class="expandable-container">
                    <div class="expandable-title"><span>6.1. 오류 처리 및 로깅</span><span class="arrow">▼</span></div>
                    <div class="expandable-content">
                        <p>OAuth 2.0 흐름 중 발생할 수 있는 다양한 오류를 처리하고 명확한 피드백을 제공해야 합니다.</p>
                        <ul>
                            <li>FastAPI의 <code>HTTPException</code>으로 일관된 오류 응답 제공.</li>
                            <li><code>Authlib</code> 예외 처리 (<code>try-except</code>).</li>
                            <li>중앙 집중식 예외 핸들러 (<code>@app.exception_handler()</code>).</li>
                            <li>상세 로깅 (<code>logging</code> 모듈, 민감 정보 제외, 구조화된 로깅).</li>
                        </ul>
                    </div>
                </div>
                <div class="expandable-container">
                    <div class="expandable-title"><span>6.2. HTTPS 강제 적용</span><span class="arrow">▼</span></div>
                    <div class="expandable-content">
                        <p>프로덕션 환경에서는 모든 통신을 HTTPS로 강제해야 합니다. 민감 정보(토큰 등) 보호에 필수적입니다.</p>
                        <ul>
                            <li>ASGI 서버 (Uvicorn 등)에 SSL/TLS 인증서 설정.</li>
                            <li>HTTP에서 HTTPS로 리디렉션 (웹 서버 또는 FastAPI 미들웨어).</li>
                            <li>HSTS (HTTP Strict Transport Security) 헤더 사용.</li>
                        </ul>
                    </div>
                </div>
                <div class="expandable-container">
                    <div class="expandable-title"><span>6.3. 범위 기반 접근 제어 (Scope-Based Access Control)</span><span class="arrow">▼</span></div>
                    <div class="expandable-content">
                        <p>사용자가 부여한 OAuth 범위(scope)를 확인하고, 이를 바탕으로 특정 기능/데이터 접근을 제어합니다.</p>
                        <ul>
                            <li>토큰 응답에서 <code>scope</code> 필드 확인.</li>
                            <li>FastAPI <code>SecurityScopes</code> 의존성을 사용하여 엔드포인트 요구 범위 선언 및 검증. (세션 또는 JWT 내 범위 정보 활용)</li>
                        </ul>
                    </div>
                </div>
                <div class="expandable-container">
                    <div class="expandable-title"><span>6.4. 프로덕션 배포 고려 사항</span><span class="arrow">▼</span></div>
                    <div class="expandable-content">
                        <ul>
                            <li><strong>보안 키 관리:</strong> 환경 변수 또는 Vault 등 비밀 관리 시스템 사용.</li>
                            <li><strong>데이터베이스 보안:</strong> 강력한 접근 제어, 정기 백업, 암호화.</li>
                            <li><strong>비율 제한 (Rate Limiting):</strong> <code>fastapi-limiter</code> 등으로 DoS 공격 방어.</li>
                            <li><strong>입력 유효성 검사:</strong> Pydantic 모델로 모든 사용자 입력 검증.</li>
                            <li><strong>CORS 설정:</strong> <code>CORSMiddleware</code>로 적절한 정책 설정.</li>
                            <li><strong>의존성 관리 및 업데이트:</strong> 최신 안정 버전 유지, 보안 취약점 점검 (<code>pip-audit</code>).</li>
                            <li><strong>ASGI 서버 최적화:</strong> 워커 수, 타임아웃 등 설정.</li>
                            <li><strong>모니터링 및 알림:</strong> 성능, 오류, 보안 이벤트 모니터링.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="conclusion" class="content-section">
                <h2>7. 결론 및 향후 방향</h2>
                <p>이 섹션에서는 연구의 주요 내용을 요약하고, FastAPI와 Google 로그인 통합의 이점, 그리고 향후 확장 및 추가 보안 강화 방안을 제시합니다.</p>

                <h3>7.1. 주요 내용 요약</h3>
                <p>본 연구는 FastAPI와 Google 로그인 API(OAuth 2.0 및 OIDC)를 단계적으로 연동하는 방법을 제시했습니다. 주요 과정은 기반 이해, Google Cloud 설정, FastAPI 프로젝트 설정, OAuth 2.0 흐름 구현 (Authlib 사용), 인증 후 관리 및 보호, 고급 주제 및 모범 사례를 포함합니다.</p>

                <h3>7.2. FastAPI와 Google 로그인 통합의 이점</h3>
                <ul>
                    <li><strong>개발 생산성 향상:</strong> FastAPI의 빠른 개발 속도와 Google 로그인으로 인한 인증 시스템 구축 부담 감소.</li>
                    <li><strong>사용자 편의성 증대:</strong> 익숙한 Google 계정으로 간편 로그인, UX 향상.</li>
                    <li><strong>보안 강화:</strong> Google의 검증된 인프라 활용, FastAPI 보안 기능과 결합.</li>
                    <li><strong>확장성:</strong> FastAPI의 비동기 처리와 Google 인프라로 유연한 대응.</li>
                    <li><strong>표준 준수:</strong> OAuth 2.0, OIDC 표준 사용으로 상호 운용성 증대.</li>
                </ul>

                <h3>7.3. 확장 및 추가 보안 강화 방안</h3>
                <ul>
                    <li>역할 기반 접근 제어 (RBAC) 구현.</li>
                    <li>2단계 인증 (2FA/MFA) 연동.</li>
                    <li>토큰 바인딩 고려.</li>
                    <li>보안 감사 및 모니터링 강화.</li>
                    <li>정기적인 보안 취약점 점검.</li>
                    <li>다른 OAuth 공급자(Facebook, GitHub 등) 통합.</li>
                    <li>비동기 데이터베이스 작업 최적화.</li>
                </ul>
                <p class="mt-4">본 연구가 FastAPI와 Google 로그인 API를 안전하고 효율적으로 연동하고자 하는 개발자들에게 실질적인 지침을 제공하고, 더 나아가 안전하고 사용자 친화적인 웹 애플리케이션 구축에 기여할 수 있기를 기대합니다.</p>
            </section>
        </main>
    </div>

    <footer class="bg-amber-700 text-white text-center p-4 mt-8">
        <p>&copy; 2024 FastAPI Google Auth Interactive Guide. 정보 제공용입니다.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const sidebarItems = document.querySelectorAll('.sidebar-item');
            const contentSections = document.querySelectorAll('.content-section');
            const expandableContainers = document.querySelectorAll('.expandable-container');
            const tabContainers = document.querySelectorAll('.tabs-container');
            const oauthFlowSteps = document.querySelectorAll('.oauth-flow-step');

            // Function to activate a section
            function activateSection(sectionId) {
                contentSections.forEach(section => {
                    section.classList.remove('active');
                    if (section.id === sectionId) {
                        section.classList.add('active');
                    }
                });
                sidebarItems.forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.section === sectionId) {
                        item.classList.add('active');
                    }
                });
                 window.scrollTo(0, 0); // Scroll to top when section changes
            }

            // Sidebar navigation
            sidebarItems.forEach(item => {
                item.addEventListener('click', function (e) {
                    e.preventDefault();
                    const sectionId = this.dataset.section;
                    activateSection(sectionId);
                });
            });

            // Expandable sections
            expandableContainers.forEach(container => {
                const title = container.querySelector('.expandable-title');
                const content = container.querySelector('.expandable-content');
                const arrow = title.querySelector('.arrow');

                title.addEventListener('click', function () {
                    const isVisible = content.style.display === 'block';
                    content.style.display = isVisible ? 'none' : 'block';
                    if (arrow) arrow.textContent = isVisible ? '▼' : '▲';
                });
            });

            // Tabs
            tabContainers.forEach(container => {
                const tabButtons = container.querySelectorAll('.tab-button');
                const tabContents = container.querySelectorAll('.tab-content');

                tabButtons.forEach(button => {
                    button.addEventListener('click', function () {
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        this.classList.add('active');

                        const tabId = this.dataset.tab;
                        tabContents.forEach(content => {
                            content.classList.remove('active');
                            if (content.id === tabId) {
                                content.classList.add('active');
                            }
                        });
                    });
                });
            });
            
            // OAuth Flow Diagram Interaction
            oauthFlowSteps.forEach(step => {
                step.addEventListener('click', function() {
                    const stepNumber = this.dataset.step;
                    const detailElement = document.getElementById(`flow-detail-${stepNumber}`);
                    
                    // Toggle active class on step for visual feedback
                    const isActive = this.classList.contains('active');
                    oauthFlowSteps.forEach(s => s.classList.remove('active')); // Remove active from all steps
                    document.querySelectorAll('.oauth-flow-details').forEach(d => d.style.display = 'none'); // Hide all details

                    if (!isActive) { // If it wasn't active, make it active and show details
                        this.classList.add('active');
                        if (detailElement) {
                            detailElement.style.display = 'block';
                        }
                    }
                    // If it was active, clicking again will effectively deactivate it and hide details (already done by the lines above)
                });
            });


            // Activate the first section by default
            if (sidebarItems.length > 0) {
                activateSection(sidebarItems[0].dataset.section);
            }
        });
    </script>
</body>
</html>
